Transform code to requirement:,code:,"private JPanel centerPanel = null;

 private JLabel desLabel = null;
 private JLabel changeLabel = null;
 private JLabel fromLabel = null;
 private JLabel toLabel = null;
 private JTextArea desText = null;
 private JTextField c Speculate Gui public SpeculateGui()
 {

super(""Speculate GUI"");

container = getContentPane();

setSize(800, 600);

this. eventServerIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserverSubmit Listener public void actionPerformed(ActionEvent e) {

 if ( e. getSource() == submitButton) {

sendQueryTO Server();

 }

 if ( e. getSource() == fetchButton) {


System. out. println(""Fetch Button Pressed void sendQueryTO Server()
 {

String ip = this. eventServerIP;
int PortNo = 1701;

Socket socket;
try {

 socket = new Socket( ip, PortNo);

 OutputStream os = socket. getOutputStream();
 OutputStreampublic void pullValueFromDOORS()
 {

String serverIP = new String( doors serverIP); //""140.192.37.150"";

String[] attribute = { ""Value"", ""Attribute"" };

String projectName = this. projNameText. get public static void main(String[] args)
 {
new SpeculateGui();
 }",requirement:,The user shall be able to construct speculative queries using a GUI.
Transform code to requirement:,code:,"Impact Report private String serverIP = "" local host"";
private JPanel centerPanel = null;
private JPanel driverPanel = new JPanel();
private JPanel driverInnerPanel = null;
private JPanel impactPanel = null;
private JPanel impactInnerP public ImpactReport()
{
super(""Search Result GUI"");
container = getContentPane();
setSize(800, 250);
panel = new JPanel();

panel. setLayout( null);

this. serverIP =
 JOptionPane
. showIn public static void main(String [] args)
 {

ImpactReport im = new ImpactReport();



 } public Vector searchDate()
 {

dateVector = new Vector();
dateVector. add(""Select Query Date"");
Socket server;
String line = new String();


try
{

 server = new Socket( serverIP,1701);
 if ( server. isC public void searchQueryID(String date)
 {

pairVector = new Vector();

queryStringCombo. removeAllItems();

queryStringCombo. addItem(""Select Query String"");

Socket server;
String line = new String(); Select Actions public void actionPerformed(ActionEvent e)
{

 if ( dateCombo == (JComboBox) e. getSource())
 {
date = (String) dateCombo. getSelectedItem();
searchQueryID( date);
 }
} Button Actionspublic void actionPerformed(ActionEvent e) {

 if ( submitButton == e. getSource()) {

for ( int i = 0; i < pairVector. size(); i++) {

 Pair pair = (Pair) pairVector. get( i);

 if ( pair
. get public void impactReport(String id)
 {

// super(""Impact Report"");

container = getContentPane();

setSize(1020, 740);

this. queryID = id;

System. out. println(""Impact Report Constructor ..... ID "" + public Vector getConstraintFromDataBase()
 {

Vector v = new Vector();

Socket server;
String line = new String();


try
{
 server = new Socket( serverIP,1701);

 if ( server. isConnected() )
 {
Bufferedpublic Vector getDriverFromDataBase()
 {

Vector v = new Vector();

 Socket server;
String line = new String();


try
{
 server = new Socket( serverIP,1701);

 if ( server. isConnected() )
 {
Buffered",requirement:,The subscribermanager shall report results indicating whether the speculative change negatively impacts other requirements and constraints.
Transform code to requirement:,code:,"Constraint Inner Panelprivate String serverIP = "" local host"";
 private JLabel performanceModelLabel = null;
 private JLabel projectNameLabel = null;
 private JLabel modulePathLabel = null;
 private JLabel requirementIdLabel = null;
 private JLabel public ConstraintInnerPanel(
String performanceModelName,
String projectName,
String modulePath,
String requirementId,
String description,
String logic,
String units,
String value,
String impactedValueprivate void set goalLabelValues(
String attribute,
String logic,
String value,
String units)
 {
goalLabel. setText(
 ""Goal : "" + attribute + """" + logic + """" + value + "" "" + units);

 }public Vector getValuesFromDataBase()
 {

Vector v = new Vector();

Socket server;
String line = new String();


try
{
 server = new Socket( serverIP,1701);

 if ( server. isConnected() )
 {
BufferedRprivate void set impactedLabelValue(
String attribute,
String value,
String impactedValue,
String units,
String logic)
 {

if ( impactedValue != null)
{

 double value1 = Double. parseDouble( value);
 dpublic JPanel getPanel()
 {
return panel;
 }",requirement:,The eventserver shall identify all related requirements and constraints for each impacted executable model.
Transform code to requirement:,code:,"Constraints Description private String projectName = null;
 private String modulePath = null;
 private String requirementID = null;

 private String value = null;
 private String logic = null;
 private String units = null;
 private String description = null;
 public ConstraintsDescription(
String projectName,
String modulePath,
String requirementID)
 {

this. projectName = projectName;
this. modulePath = modulePath;
this. requirementID = requirementID;

 }public String getDescription() {
return this. description;
 }public String getLogic() {
return this. logic;
 }public String getModulePath() {
return this. modulePath;
 }public String getProjectName() {
return this. projectName;
 }public String getRequirementID() {
return this. requirementID;
 }public String getUnits() {
return this. units;
 }public String getValue() {
return this. value;
 }public void setDescription(String description) {
this. description = description;
 }public void setLogic(String logic) {
this. logic = logic;
 }public void setModulePath(String modulePath) {
this. modulePath = modulePath;
 }public void setProjectName(String projectName) {
this. projectName = projectName;
 }public void setRequirementID(String requirementID) {
this. requirementID = requirementID;
 }public void setUnits(String units) {
this. units = units;
 }public void setValue(String units) {
this. value = units;
 }public String getImpactedConstraint() {
return this. impactedConstraint;
 }public void setImpactedConstraint(String impactedConstraint) {
this. impactedConstraint = impactedConstraint;
 }public String getAttribute() {
return this. attribute;
 }public void setAttribute(String attribute) {
this. attribute = attribute;
 }public String getPerformanceModelName() {
return this. performanceModelName;
 }public void setPerformanceModelName(String performanceModelName) {
this. performanceModelName = performanceModelName;
 } public String toString() {

String str =
 ""\ nProject Name = ""
+ this. projectName
+ ""\ n""
+ ""Module Path = ""
+ this. modulePath
+ ""\ n""
+ ""Requirement ID = ""
+ this. requirementID
+ ""\ n""
 public boolean equals(Object o) {

if (!( o instance of ConstraintsDescription))
 return false;

ConstraintsDescription cd = (ConstraintsDescription) o;

if ( cd. projectName. equalsIgnoreCase( this. projectNapublic int hashCode() {

int hashCode = 0;

if ( hashCode == 0) {
 int result = 17;
 result = 37 * result + this. projectName. hashCode();
 result = 37 * result + this. modulePath. hashCode();
 result = 37 * ",requirement:,The eventserver shall identify all related requirements and constraints for each impacted executable model.
Transform code to requirement:,code:,"Driver Description private String projectName = null;
 private String modulePath = null;
 private String requirementID = null;

 private String description = null; // Description of the requirement.
 private String changedArrtibute = null;
 private Strinpublic DriverDescription(
String projectName,
String modulePath,
String requirementID,
String description,
String changedAttribute,
String fromAttribute,
String toAttribute)
 {

this. projectName = projecpublic String getChangedAttribute()
 {
return changedAttribute;
 }public String getDescription()
 {
return description;
 }public String getFromAttribute()
 {
return fromAttribute;
 } public String getModulePath()
 {
return modulePath;
 }public String getProjectName()
 {
return projectName;
 } public String getRequirementID()
 {
return requirementID;
 } public String getToAttribute()
 {
return toAttribute;
 } public void setChangedAttribute(String changedAttribute)
 {
this. changedAttribute = changedAttribute;
 } public void setDescription(String description)
 {
this. description = description;
 } public void setFromAttribute(String fromAttribute)
 {
this. fromAttribute = fromAttribute;
 } public void setModulePath(String modulePath)
 {
this. modulePath = modulePath;
 } public void setProjectName(String projectName)
 {
this. projectName = projectName;
 } public void setRequirementID(String requirementID)
 {
this. requirementID = requirementID;
 } public void setToAttribute(String toAttribute)
 {
this. toAttribute = toAttribute;
 } public String createKey()
 {
String key =
 this. projectName + this. modulePath + ""\\"" + this. requirementID;

return key. toLowerCase();

 } public boolean equals(Object o)
 {
if (!( o instance of DriverDescription))
 return false;

DriverDescription dd = (DriverDescription) o;

if ( dd. projectName. equalsIgnoreCase( this. projectName)
 && ddpublic String toString()
 {

String str =
 ""\ nProject Name = ""
+ this. projectName
+ ""\ n""
+ ""Module Path = ""
+ this. modulePath
+ ""\ n""
+ ""Requirement ID = ""
+ this. requirementID
+ ""\ n""
public int hashCode()
 {

int hashCode = 0;

if ( hashCode == 0)
{
 int result = 17;
 result = 37 * result + this. projectName. hashCode();
 result = 37 * result + this. modulePath. hashCode();
 result = 37 ",requirement:,The eventserver shall identify all related requirements and constraints for each impacted executable model.
Transform code to requirement:,code:,"Driver Inner Panel private JLabel projectNameLabel = null;
 private JLabel modulePathLabel = null;
 private JLabel requirementIdLabel = null;
 private JLabel desLabel = null;
 private JLabel changeLabel = null;
 private JLabel fromLabel = null;String projectName,
String modulePath,
String requirementID,
String description,
String changeAttribute,
String fromValue,
String toValue) {

panel = new JPanel();

panel. setBackground(Color.LIGHTpublic JPanel createPanel() {

return panel;
 }",requirement:,The eventserver shall identify all related requirements and constraints for each impacted executable model.
Transform code to requirement:,code:,"eventserver public static void main(String args[])
 {

ThreadPool pool = new ThreadPool(1);

 int port = defaultPort;
 try
 {
 ServerSocket ss = new ServerSocket( port);
 for( int i=0; i<4; i++)
 {
p public final static int defaultPort = 1701;
 ServerSocket theServer;",requirement:,The subscribermanager shall immediately process speculative events.
Transform code to requirement:,code:,"eventserver Threadstatic private int count = 0;
 private int taskNumber;
 protected Done done;
 ServerSocket theServer;

 private Connection conn;
 private Statement stmt;
 private ResultSet rs;

 private EventParser ep;
 private int id; EventServerThread(ServerSocket ss)
 {
 theServer = ss;
 count++;
 taskNumber = count;
 ep = new EventParser();
 } public void run()
 {

 while( true)
 {
 try
 {

Socket client = theServer. accept();
BufferedReader input = new BufferedReader( new InputStreamReader( client. getInputStream()));
PrintWriter output = new P public String getNextID()
 {

try
{
Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
this. conn = DriverManager. getConnection("" jdbc: odbc:EBT"",""EBT"",""EBT"");
this. stmt = connpublic String searchDate()
 {

String dateString = new String();
Vector dateVector = new Vector();

try
{

 Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
 Connection conn = DriverManager. getConnectio public String searchQueryID(String date)
 {
Vector queryVector = new Vector();

String searchQuery = new String();

try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 conn = DriverManager. getpublic String getConstraintFromDataBase(String queryID)
 {

String ConstString = new String();


try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" j public String getDriverFromDataBase(String queryID)
 {

String driverString = new String();

try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" jdbc ",requirement:,The subscribermanager shall immediately process speculative events.
Transform code to requirement:,code:,"eventserver Threadstatic private int count = 0;
 private int taskNumber;
 protected Done done;
 ServerSocket theServer;

 private Connection conn;
 private Statement stmt;
 private ResultSet rs;

 private EventParser ep;
 private int id; EventServerThread(ServerSocket ss)
 {
 theServer = ss;
 count++;
 taskNumber = count;
 ep = new EventParser();
 } public void run()
 {

 while( true)
 {
 try
 {

Socket client = theServer. accept();
BufferedReader input = new BufferedReader( new InputStreamReader( client. getInputStream()));
PrintWriter output = new P public String getNextID()
 {

try
{
Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
this. conn = DriverManager. getConnection("" jdbc: odbc:EBT"",""EBT"",""EBT"");
this. stmt = connpublic String searchDate()
 {

String dateString = new String();
Vector dateVector = new Vector();

try
{

 Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
 Connection conn = DriverManager. getConnectio public String searchQueryID(String date)
 {
Vector queryVector = new Vector();

String searchQuery = new String();

try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 conn = DriverManager. getpublic String getConstraintFromDataBase(String queryID)
 {

String ConstString = new String();


try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" j public String getDriverFromDataBase(String queryID)
 {

String driverString = new String();

try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" jdbc ",requirement:,On receipt of an event message the eventserver shall record the event in an eventlog.
Transform code to requirement:,code:,"eventserver Threadstatic private int count = 0;
 private int taskNumber;
 protected Done done;
 ServerSocket theServer;

 private Connection conn;
 private Statement stmt;
 private ResultSet rs;

 private EventParser ep;
 private int id; EventServerThread(ServerSocket ss)
 {
 theServer = ss;
 count++;
 taskNumber = count;
 ep = new EventParser();
 } public void run()
 {

 while( true)
 {
 try
 {

Socket client = theServer. accept();
BufferedReader input = new BufferedReader( new InputStreamReader( client. getInputStream()));
PrintWriter output = new P public String getNextID()
 {

try
{
Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
this. conn = DriverManager. getConnection("" jdbc: odbc:EBT"",""EBT"",""EBT"");
this. stmt = connpublic String searchDate()
 {

String dateString = new String();
Vector dateVector = new Vector();

try
{

 Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
 Connection conn = DriverManager. getConnectio public String searchQueryID(String date)
 {
Vector queryVector = new Vector();

String searchQuery = new String();

try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 conn = DriverManager. getpublic String getConstraintFromDataBase(String queryID)
 {

String ConstString = new String();


try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" j public String getDriverFromDataBase(String queryID)
 {

String driverString = new String();

try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" jdbc ",requirement:,The eventserver shall differentiate between evolutionary and speculative events.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,The user shall be able to delete subscriptions.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,The subscribermanager shall immediately process speculative events.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,The subscribermanager shall report results indicating whether the speculative change negatively impacts other requirements and constraints.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,On receipt of an event message the eventserver shall record the event in an eventlog.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,On receipt of an event; the eventserver shall identify all relevant subscribers for the event.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,The eventserver shall create a composite speculative message which includes the speculative event plus all related requirements and constraint values for each impacted model.
Transform code to requirement:,code:,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()",requirement:,The eventserver shall send the customized message to each impacted executable model.
Transform code to requirement:,code:,"Event Notifier // Variables to process the requirement
 private String requirement No;//Requirement No.
 private String ProjName; //Project name
 private String ModPath;//Modular path
 private String requirement Text;/ public EventNotifier(String rno, String proj, String mod, String rtext,String eID, String em, String eventType)
 {
requirement No = rno;//Requirement number
ProjName = proj;// project name
ModPath = mo // finds the subscribers for this requirement
 public void IdentifySubscribers()
 {
String mSQL;
// Create an SQL statement that will limit the selection as much as possible
// If a subscription is to a specific requirement - check for requi //Reads the result from IdentifySubscribers method selection
 // and adds each result into ActualSubscribers Vector.
 void ProcessResultSet()
 {

String sName, sReqno, sModule, sKey1, sKey2;
try
{
 System. o // Send messages to all subscribers listed in ActualSubscriber Vector
// Possible that a sort routine can be added later so that all notification to
// the same subscribermanager can be batched.This is not implemented yet.

 public void Dispatch public String getErrorMessage()
 {
 return errMsg;

 } public boolean Contains(String ContextString, String SearchString)
 {
int cLen = ContextString. length();
int sLen = SearchString. length();
if (SearchString. length() == 0)
 return false;

for ( int i = 0",requirement:,If the subscribermanager is online; the push model shall be used to send it event notifications in real time.
Transform code to requirement:,code:,"Event Notifier // Variables to process the requirement
 private String requirement No;//Requirement No.
 private String ProjName; //Project name
 private String ModPath;//Modular path
 private String requirement Text;/ public EventNotifier(String rno, String proj, String mod, String rtext,String eID, String em, String eventType)
 {
requirement No = rno;//Requirement number
ProjName = proj;// project name
ModPath = mo // finds the subscribers for this requirement
 public void IdentifySubscribers()
 {
String mSQL;
// Create an SQL statement that will limit the selection as much as possible
// If a subscription is to a specific requirement - check for requi //Reads the result from IdentifySubscribers method selection
 // and adds each result into ActualSubscribers Vector.
 void ProcessResultSet()
 {

String sName, sReqno, sModule, sKey1, sKey2;
try
{
 System. o // Send messages to all subscribers listed in ActualSubscriber Vector
// Possible that a sort routine can be added later so that all notification to
// the same subscribermanager can be batched.This is not implemented yet.

 public void Dispatch public String getErrorMessage()
 {
 return errMsg;

 } public boolean Contains(String ContextString, String SearchString)
 {
int cLen = ContextString. length();
int sLen = SearchString. length();
if (SearchString. length() == 0)
 return false;

for ( int i = 0",requirement:,A subscribermanager shall receive event notifications on behalf of the artifacts that it manages.
Transform code to requirement:,code:,"Event Notifier // Variables to process the requirement
 private String requirement No;//Requirement No.
 private String ProjName; //Project name
 private String ModPath;//Modular path
 private String requirement Text;/ public EventNotifier(String rno, String proj, String mod, String rtext,String eID, String em, String eventType)
 {
requirement No = rno;//Requirement number
ProjName = proj;// project name
ModPath = mo // finds the subscribers for this requirement
 public void IdentifySubscribers()
 {
String mSQL;
// Create an SQL statement that will limit the selection as much as possible
// If a subscription is to a specific requirement - check for requi //Reads the result from IdentifySubscribers method selection
 // and adds each result into ActualSubscribers Vector.
 void ProcessResultSet()
 {

String sName, sReqno, sModule, sKey1, sKey2;
try
{
 System. o // Send messages to all subscribers listed in ActualSubscriber Vector
// Possible that a sort routine can be added later so that all notification to
// the same subscribermanager can be batched.This is not implemented yet.

 public void Dispatch public String getErrorMessage()
 {
 return errMsg;

 } public boolean Contains(String ContextString, String SearchString)
 {
int cLen = ContextString. length();
int sLen = SearchString. length();
if (SearchString. length() == 0)
 return false;

for ( int i = 0",requirement:,On receipt of an event message; the subscribermanager shall differentiate between speculative and evolutionary events.
Transform code to requirement:,code:,"Event Notifier // Variables to process the requirement
 private String requirement No;//Requirement No.
 private String ProjName; //Project name
 private String ModPath;//Modular path
 private String requirement Text;/ public EventNotifier(String rno, String proj, String mod, String rtext,String eID, String em, String eventType)
 {
requirement No = rno;//Requirement number
ProjName = proj;// project name
ModPath = mo // finds the subscribers for this requirement
 public void IdentifySubscribers()
 {
String mSQL;
// Create an SQL statement that will limit the selection as much as possible
// If a subscription is to a specific requirement - check for requi //Reads the result from IdentifySubscribers method selection
 // and adds each result into ActualSubscribers Vector.
 void ProcessResultSet()
 {

String sName, sReqno, sModule, sKey1, sKey2;
try
{
 System. o // Send messages to all subscribers listed in ActualSubscriber Vector
// Possible that a sort routine can be added later so that all notification to
// the same subscribermanager can be batched.This is not implemented yet.

 public void Dispatch public String getErrorMessage()
 {
 return errMsg;

 } public boolean Contains(String ContextString, String SearchString)
 {
int cLen = ContextString. length();
int sLen = SearchString. length();
if (SearchString. length() == 0)
 return false;

for ( int i = 0",requirement:,On receipt of an event; the eventserver shall identify all relevant subscribers for the event.
Transform code to requirement:,code:,"Event Notifier // Variables to process the requirement
 private String requirement No;//Requirement No.
 private String ProjName; //Project name
 private String ModPath;//Modular path
 private String requirement Text;/ public EventNotifier(String rno, String proj, String mod, String rtext,String eID, String em, String eventType)
 {
requirement No = rno;//Requirement number
ProjName = proj;// project name
ModPath = mo // finds the subscribers for this requirement
 public void IdentifySubscribers()
 {
String mSQL;
// Create an SQL statement that will limit the selection as much as possible
// If a subscription is to a specific requirement - check for requi //Reads the result from IdentifySubscribers method selection
 // and adds each result into ActualSubscribers Vector.
 void ProcessResultSet()
 {

String sName, sReqno, sModule, sKey1, sKey2;
try
{
 System. o // Send messages to all subscribers listed in ActualSubscriber Vector
// Possible that a sort routine can be added later so that all notification to
// the same subscribermanager can be batched.This is not implemented yet.

 public void Dispatch public String getErrorMessage()
 {
 return errMsg;

 } public boolean Contains(String ContextString, String SearchString)
 {
int cLen = ContextString. length();
int sLen = SearchString. length();
if (SearchString. length() == 0)
 return false;

for ( int i = 0",requirement:,When an evolutionary event occurs; the eventserver shall notify subscribers of the event.
Transform code to requirement:,code:,"Subscribed Model private String SubscriberName;
private String SubscriberReqno;
private String SubscriberModule;
private String SubscriberKeyword1;
private String SubscriberKeyword2;public SubscribedModel(String sn, String sr, String sm, String sk1, String sk2)
{
SubscriberName = sn;
SubscriberReqno = sr;
SubscriberModule = sm;
SubscriberKeyword1 = sk1;
SubscriberKeyword2 = s public String GetSubscriberName() { return SubscriberName;} public String GetSubscriberReqno() { return SubscriberReqno;} public String GetSubscriberModule() { return SubscriberModule;} public String GetSubscriberKeyword1() { return SubscriberKeyword1;} public String GetSubscriberKeyword2() { return SubscriberKeyword2;}",requirement:,A user shall register as a subscriber.
Transform code to requirement:,code:,"Subscribed Model private String SubscriberName;
private String SubscriberReqno;
private String SubscriberModule;
private String SubscriberKeyword1;
private String SubscriberKeyword2;public SubscribedModel(String sn, String sr, String sm, String sk1, String sk2)
{
SubscriberName = sn;
SubscriberReqno = sr;
SubscriberModule = sm;
SubscriberKeyword1 = sk1;
SubscriberKeyword2 = s public String GetSubscriberName() { return SubscriberName;} public String GetSubscriberReqno() { return SubscriberReqno;} public String GetSubscriberModule() { return SubscriberModule;} public String GetSubscriberKeyword1() { return SubscriberKeyword1;} public String GetSubscriberKeyword2() { return SubscriberKeyword2;}",requirement:,On registration a subscriber shall register itself under the control of a subscribermanager
Transform code to requirement:,code:,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop",requirement:,The subscribermanager shall immediately process speculative events.
Transform code to requirement:,code:,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop",requirement:,The subscribermanager shall report results indicating whether the speculative change negatively impacts other requirements and constraints.
Transform code to requirement:,code:,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop",requirement:,For speculative events; the eventserver shall construct a composite event message.
Transform code to requirement:,code:,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop",requirement:,The eventserver shall retrieve quantitative values related to these additional requirements and constraints through querying the requirements management tool.
Transform code to requirement:,code:,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop",requirement:,The eventserver shall create a composite speculative message which includes the speculative event plus all related requirements and constraint values for each impacted model.
Transform code to requirement:,code:,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop",requirement:,The eventserver shall send the customized message to each impacted executable model.
Transform code to requirement:,code:,"Doors Thread static private int count = 0;
 private int taskNumber;
 protected Done done;
 ServerSocket theServer;

 private Connection conn;
 private Statement stmt;
 private ResultSet rs; DOORsThread(ServerSocket ss)
 {
 theServer = ss;
 count++;
 taskNumber = count;
 } public void run()
 {

 while( true)
 {
 try
 {

Socket client = theServer. accept();
BufferedReader input = new BufferedReader( new InputStreamReader( client. getInputStream()));
PrintWriter output = new P",requirement:,The eventserver shall retrieve quantitative values related to these additional requirements and constraints through querying the requirements management tool.
Transform code to requirement:,code:,"DOORs Thread Pool public final static int defaultPort = 2347;
 ServerSocket theServer;
 // static int numberOfThreads = 3; //@param argsNo arguments are used.
 public static void main(String args[])
 {

ThreadPool pool = new ThreadPool(1);

 int port = defaultPort;
 try
 {
 ServerSocket ss = new ServerSocket( port);
 for",requirement:,The eventserver shall retrieve quantitative values related to these additional requirements and constraints through querying the requirements management tool.
Transform code to requirement:,code:,"DOORs Thread Pool public final static int defaultPort = 2347;
 ServerSocket theServer;
 // static int numberOfThreads = 3; //@param argsNo arguments are used.
 public static void main(String args[])
 {

ThreadPool pool = new ThreadPool(1);

 int port = defaultPort;
 try
 {
 ServerSocket ss = new ServerSocket( port);
 for",requirement:,The user shall view all evolutionary events received for a specific artifact in the order in which they were received.
Transform code to requirement:,code:,"Event Detail Dialog private GridBagLayout grid bag;
private GridBagConstraints c;

// objects in top panel
private JPanel topPanel;
private JLabel modelLabel;
private JLabel typeLabel;
private JTextField modelField;
p public EventDetailDialog(EventsProcessor parent, boolean modal,Notification_Event nEvt, boolean mode)
{

super ( parent, modal);
 setTitle(""Event Details"");
 getContentPane (). setLayout (private void closeDialog(WindowEvent evt)
{
setVisible ( false);
dispose ();
} // event listener for ""Ok/Update"" button
private void okButtonActionPerformed (ActionEvent evt)
{

 if ( displayMode == true)
 {

// m_ parent.DeleteEvent( m_Evt. m_SubscriberName, m_ // event listener for ""Cancel"" button
private void cancelButtonActionPerformed (ActionEvent evt)
{
setVisible ( false);
dispose ();
} private void LeftListClicked(MouseEvent e){

 if (!LeftList. isSelectionEmpty()) {

 int index = LeftList. getSelectedIndex();
 Requirement requirement= (Requirement) m_Evt. m_LeftSideprivate void RightListClicked(MouseEvent e){

 if (!RightList. isSelectionEmpty()) {

 int index = RightList. getSelectedIndex();
 Requirement requirement= (Requirement) m_Evt. m_RightS",requirement:,The user shall view all evolutionary events received for a specific artifact in the order in which they were received.
Transform code to requirement:,code:,"Event Detail Dialog private GridBagLayout grid bag;
private GridBagConstraints c;

// objects in top panel
private JPanel topPanel;
private JLabel modelLabel;
private JLabel typeLabel;
private JTextField modelField;
p public EventDetailDialog(EventsProcessor parent, boolean modal,Notification_Event nEvt, boolean mode)
{

super ( parent, modal);
 setTitle(""Event Details"");
 getContentPane (). setLayout (private void closeDialog(WindowEvent evt)
{
setVisible ( false);
dispose ();
} // event listener for ""Ok/Update"" button
private void okButtonActionPerformed (ActionEvent evt)
{

 if ( displayMode == true)
 {

// m_ parent.DeleteEvent( m_Evt. m_SubscriberName, m_ // event listener for ""Cancel"" button
private void cancelButtonActionPerformed (ActionEvent evt)
{
setVisible ( false);
dispose ();
} private void LeftListClicked(MouseEvent e){

 if (!LeftList. isSelectionEmpty()) {

 int index = LeftList. getSelectedIndex();
 Requirement requirement= (Requirement) m_Evt. m_LeftSideprivate void RightListClicked(MouseEvent e){

 if (!RightList. isSelectionEmpty()) {

 int index = RightList. getSelectedIndex();
 Requirement requirement= (Requirement) m_Evt. m_RightS",requirement:,The user shall update related artifacts according to the information contained in the event messages.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,The user shall be able to delete subscriptions.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,A subscribermanager shall manage traces for one or more artifacts.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,Event types shall include decomposing one requirement into two or more requirements.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,Event types shall include merging requirements.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,The user shall view all evolutionary events received for a specific artifact in the order in which they were received.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,The user shall update related artifacts according to the information contained in the event messages.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,The user shall eliminate unnecessary traces that were temporarily constructed by the eventserver during initial event processing.
Transform code to requirement:,code:,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag",requirement:,The notification processing system shall automatically eliminate any events that are not longer valid as a result of the user eliminating temporary traces.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,A subscribermanager shall manage traces for one or more artifacts.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,Event types shall include decomposing one requirement into two or more requirements.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,Event types shall include merging requirements.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI",requirement:,The user shall update related artifacts according to the information contained in the event messages.
Transform code to requirement:,code:,"Notification Processing // member variables for menu
 private JMenuBar menuBar;

 // subscriber list
 private JList SubscriberList;
 private DefaultListModel listModel;

 // popup menu

 private JPopupMenu popup;

 // database and eventserver information
 S public Notification_Processing()
 {

setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEvent evt)
 {
try
public static void main(String args[])
 {
try
{
 Notification_Processing mainFrame = new Notification_Processing();
 mainFrame. setSize(600, 400);
 mainFrame. setLocation(100, 100);
 mainFrame. void exitApplication()
{
try
{
int reply = JOptionPane. showConfirmDialog( this,
""Do you really want to exit?"",
""No // action for ""Open log database""
 private void openMenuItemActionPerformed (ActionEvent evt)
 {
new ConfigDialog( this, true). show();

 if( m_DSN. equals("""") || m_EventServerIP. equals("""") || m_// action for ""Close log database""
 private void saveMenuItemActionPerformed (ActionEvent evt)
 {
try
{
 m_ conn. close();
 m_DSN="""";
 m_EventServerIP="""";
 m_EventServerPort="""";

 // action for "" exit""
 private void exitMenuItemActionPerformed (ActionEvent evt)
 {
exitApplication();
 } // action for ""Open Events"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
openEventsMenuItemActionPerformed( evt);
 } // action for ""Open Events""
 private void openEventsMenuItemActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index = SubscriberList. getSelectedIndex();
 if ( index != -1)
 // action for "" double click on Subscriber List""
 private void doubleClickSubscriberList (MouseEvent evt)
 {
if (! listModel. isEmpty())
{
 int index = SubscriberList. getSelectedIndex();
 if ( index != -1 // action for ""About""
 private void aboutMenuItemActionPerformed (ActionEvent evt)
 {
new AboutDialog ( this, true). show();
 } void UpdateDisplayList()
 {
listModel. removeAllElements();

 String mSQL = ""SELECT distinct SubscriberName FROM EventDetails"";

try
{
 rs = stmt. executeQuery( mSQL);
 while ( rs. next())
 {
 ",requirement:,A subscribermanager shall manage traces for one or more artifacts.
Transform code to requirement:,code:,"Notification Processing // member variables for menu
 private JMenuBar menuBar;

 // subscriber list
 private JList SubscriberList;
 private DefaultListModel listModel;

 // popup menu

 private JPopupMenu popup;

 // database and eventserver information
 S public Notification_Processing()
 {

setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEvent evt)
 {
try
public static void main(String args[])
 {
try
{
 Notification_Processing mainFrame = new Notification_Processing();
 mainFrame. setSize(600, 400);
 mainFrame. setLocation(100, 100);
 mainFrame. void exitApplication()
{
try
{
int reply = JOptionPane. showConfirmDialog( this,
""Do you really want to exit?"",
""No // action for ""Open log database""
 private void openMenuItemActionPerformed (ActionEvent evt)
 {
new ConfigDialog( this, true). show();

 if( m_DSN. equals("""") || m_EventServerIP. equals("""") || m_// action for ""Close log database""
 private void saveMenuItemActionPerformed (ActionEvent evt)
 {
try
{
 m_ conn. close();
 m_DSN="""";
 m_EventServerIP="""";
 m_EventServerPort="""";

 // action for "" exit""
 private void exitMenuItemActionPerformed (ActionEvent evt)
 {
exitApplication();
 } // action for ""Open Events"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
openEventsMenuItemActionPerformed( evt);
 } // action for ""Open Events""
 private void openEventsMenuItemActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index = SubscriberList. getSelectedIndex();
 if ( index != -1)
 // action for "" double click on Subscriber List""
 private void doubleClickSubscriberList (MouseEvent evt)
 {
if (! listModel. isEmpty())
{
 int index = SubscriberList. getSelectedIndex();
 if ( index != -1 // action for ""About""
 private void aboutMenuItemActionPerformed (ActionEvent evt)
 {
new AboutDialog ( this, true). show();
 } void UpdateDisplayList()
 {
listModel. removeAllElements();

 String mSQL = ""SELECT distinct SubscriberName FROM EventDetails"";

try
{
 rs = stmt. executeQuery( mSQL);
 while ( rs. next())
 {
 ",requirement:,The user shall view all evolutionary events received for a specific artifact in the order in which they were received.
Transform code to requirement:,code:,"database QueryConnection conn=null;
 ResultSet rs=null;
 Statement stmt=null;
 String mSQL="""";

 Vector structVector = new Vector(); // for holding the dummy variable objects used in executeStructure()
 Variable v;// create this object and /**
 * Construct a connection object.
 * @param Returns an object of type Connection
 */
 public Connection getConnection()
 {
System. out. println("" in get Connection"");
Connection connect=null;
try
{
 Class. fo /**
* Returns GraphId as int
* @param graphName performance modelHandler calls this method with graphName
* as parameter, performance modelHandler parse the EventServer message and get the
* graphName
*/
 public int get /**
* Copy data from one set of columns to other in table Variable
* @param graphId is the id of graph for which you want to save the
* current state of variables
*/
 public void saveCurrentModel( int graphId)
 {

conn = this. getConnect/**
* Injects new value into Variable table, using Data stored in
* Vector of Variable object
* @param graphId is the id of graph
* @param Vector var is the Vector that stores the Object of type Variable
*/
 public void injectVa /**
* this method will pick up the structure id from SPE Structure
* If DependentStructureId is 0 then select StructureID
* and invoke the executeStructure method on Selected
* StructureId
* Who Invokes this method: performance model // this method is about executing the structure
 // based on StructureId find all the data related to given StructureId
 // and using the equation in string format call the method equationParser.
 //I am passing Vector that has all the data abou public void solveStructure( int StructureId, Vector vr)
 {
System. out. println(""Inside solveStructure()&&&&&&&&&&&&&&&&&&&&&&&"");

Connection conn1 = this. getConnection();
System. out. println("" in solveStru public void solveStructureEquation()
 {
System. out. println(""Inside solveStructureEquation()%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"");

//Based on that result find out the equation and replace the name by its value
System public void getTrackVariableName()
 {
System. out. println(""Inside getTrackVariableName()$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"");
//This will get the variable name from SPE Graph and find the same name in variable
// and inse public void setCalculatedValues()
 {
System. out. println(""Inside setCalculatedValues()>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"");
// and at matching location put the calculated values
System. out. println("" enter calcValue // this method creates the token for each variable name in the string
 // and store that variable into vector
 // it also creates the vector called varValues
 // varValues has values of each variable stored in varName
 //So equation has variable n public Vector getImpactReport()
 {
//This SPE Graph works on the assumption that each model tracks
// the effect of changes on one variable
Vector report = new Vector();
report. add( trackVariableName);
report. add(Stri",requirement:,The subscribermanager shall re execute the model using the speculative values.
Transform code to requirement:,code:,"Model Driver String msg=""""; public ModelDriver(String text)
 {
this. msg = text;
init();
 } public void init()
 {

System. out. println(""MODEL DRIVER CLASS 1/10"");
performance modelHandler pmh = new performance modelHandler( msg);
System. out. println(""MODEL DRIVER CLASS 2/10"");
 pmh. messageParser",requirement:,The subscribermanager shall re execute the model using the speculative values.
Transform code to requirement:,code:,"Model Driver String msg=""""; public ModelDriver(String text)
 {
this. msg = text;
init();
 } public void init()
 {

System. out. println(""MODEL DRIVER CLASS 1/10"");
performance modelHandler pmh = new performance modelHandler( msg);
System. out. println(""MODEL DRIVER CLASS 2/10"");
 pmh. messageParser",requirement:,The subscribermanager shall report results indicating whether the speculative change negatively impacts other requirements and constraints.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Whenever the subscribermanager first comes on line; it shall implement the pull model to retrieve outstanding event messages from the eventserver.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,The subscribermanager shall re execute the model using the speculative values.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Event types shall include decomposing one requirement into two or more requirements.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,Event types shall include merging requirements.
Transform code to requirement:,code:,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" ",requirement:,The eventserver shall receive event messages when a requirement changes.
Transform code to requirement:,code:,"performance model Handler String strES; // string received from eventserver
 String impactReport;// string to be send to eventServer

 String commandStr; // represent the command ex. execute, re - execute etc
 String eventId;// refers to the eventId
 String performance model Handler(String msg)
 {
this. strES = msg;
 } public void messageParser()
 {
System. out. println(""INSIDE PARSER"");

mainSto = new StringTokenizer( strES,""|""); // current ex will have 10 tokens in mainSto


tempStr1 = mainSto. nextToken();
//Re-execut public String generateReport()
{
 System. out. println(""INSIDE generateReport"");

 mainSto = new StringTokenizer( strES,""|""); // current ex will have 10 tokens in mainSto
 /*
""ImpactReport|1015818161020| int grId; public int getId(){
 // get GraphId
 System. out. println(""database start"");
 int grId = database. getGraphId( modelName);
 return grId;
 } public void saveModel( int id)
 {
// save current model
database. saveCurrentModel( id);
 } public void insertData( int id){
// inject data into model
database. injectVariables( id, variable);
 } public void execute( int id){
// inject data into model
database. executeModel( id, variable);
 }",requirement:,The subscribermanager shall re execute the model using the speculative values.
Transform code to requirement:,code:,"performance model Handler String strES; // string received from eventserver
 String impactReport;// string to be send to eventServer

 String commandStr; // represent the command ex. execute, re - execute etc
 String eventId;// refers to the eventId
 String performance model Handler(String msg)
 {
this. strES = msg;
 } public void messageParser()
 {
System. out. println(""INSIDE PARSER"");

mainSto = new StringTokenizer( strES,""|""); // current ex will have 10 tokens in mainSto


tempStr1 = mainSto. nextToken();
//Re-execut public String generateReport()
{
 System. out. println(""INSIDE generateReport"");

 mainSto = new StringTokenizer( strES,""|""); // current ex will have 10 tokens in mainSto
 /*
""ImpactReport|1015818161020| int grId; public int getId(){
 // get GraphId
 System. out. println(""database start"");
 int grId = database. getGraphId( modelName);
 return grId;
 } public void saveModel( int id)
 {
// save current model
database. saveCurrentModel( id);
 } public void insertData( int id){
// inject data into model
database. injectVariables( id, variable);
 } public void execute( int id){
// inject data into model
database. executeModel( id, variable);
 }",requirement:,The subscribermanager shall report results indicating whether the speculative change negatively impacts other requirements and constraints.
Transform code to requirement:,code:,"subscribermanager Socket aSocket;
 int ID;
 String EventLog;

 Connection conn;
 ResultSet rs;
 Statement stmt; // constructor, this object will be created in the main method of these class
 SubscriberListener() { } // constructor, this object will be created in the main method of these class
 SubscriberListener(Socket socket, int ID, String ELog)
 {

 this. aSocket = socket;
this.ID = ID;
this.EventLog = ELog;

try
{
public void sendImpactReportToEventServer(String text)
 {

//String impactReport = text;
System. out. println(""WOW IN SEND REPORT"");
System. out. println(""The IR = ""+ text);
String serverIP = ""140. // run method will be execute from the main method when u say Thread. start() in main
 public void run()
 {

System. out. println(""Inside Run method"");

String str="""";
try
{
 // set up for reading the byte data in to characte // start of class from here
 public static void main(String[] args)
 {
// default port number
int port = 1705;
// the message coming from eventserver
String LogName = ""EventLog"";
//LogName is the database name used to log t",requirement:,The subscribermanager shall store information for evolutionary events in an eventlog.
Transform code to requirement:,code:,"subscribermanager Socket aSocket;
 int ID;
 String EventLog;

 Connection conn;
 ResultSet rs;
 Statement stmt; // constructor, this object will be created in the main method of these class
 SubscriberListener() { } // constructor, this object will be created in the main method of these class
 SubscriberListener(Socket socket, int ID, String ELog)
 {

 this. aSocket = socket;
this.ID = ID;
this.EventLog = ELog;

try
{
public void sendImpactReportToEventServer(String text)
 {

//String impactReport = text;
System. out. println(""WOW IN SEND REPORT"");
System. out. println(""The IR = ""+ text);
String serverIP = ""140. // run method will be execute from the main method when u say Thread. start() in main
 public void run()
 {

System. out. println(""Inside Run method"");

String str="""";
try
{
 // set up for reading the byte data in to characte // start of class from here
 public static void main(String[] args)
 {
// default port number
int port = 1705;
// the message coming from eventserver
String LogName = ""EventLog"";
//LogName is the database name used to log t",requirement:,The subscribermanager shall re execute the model using the speculative values.
Transform code to requirement:,code:,"subscribermanager Socket aSocket;
 int ID;
 String EventLog;

 Connection conn;
 ResultSet rs;
 Statement stmt; // constructor, this object will be created in the main method of these class
 SubscriberListener() { } // constructor, this object will be created in the main method of these class
 SubscriberListener(Socket socket, int ID, String ELog)
 {

 this. aSocket = socket;
this.ID = ID;
this.EventLog = ELog;

try
{
public void sendImpactReportToEventServer(String text)
 {

//String impactReport = text;
System. out. println(""WOW IN SEND REPORT"");
System. out. println(""The IR = ""+ text);
String serverIP = ""140. // run method will be execute from the main method when u say Thread. start() in main
 public void run()
 {

System. out. println(""Inside Run method"");

String str="""";
try
{
 // set up for reading the byte data in to characte // start of class from here
 public static void main(String[] args)
 {
// default port number
int port = 1705;
// the message coming from eventserver
String LogName = ""EventLog"";
//LogName is the database name used to log t",requirement:,The subscribermanager shall report results indicating whether the speculative change negatively impacts other requirements and constraints.
Transform code to requirement:,code:,"Variable String id = """"; // requirement id ex WB10
 String type= """"; // type of requirement ex Driver or Constraints
 String name= """"; // requirement name which is same as variable name in graph
 double value= 0.0; // value of variable
 double speculat //General Constructor to initialize all the members
 Variable(String id, String type, String name, double value, double speculateValue, String logic, String project_ path)
 {
this. id = id;
this. type = type;
this.//Constructor to Add driver related members
 Variable(String id, String type, String name, double value, double speculateValue)
 {
this. id = id;
this. type = type;
this. name = name;
this. value = value;
this //Constructor to Add constraints related members
 Variable(String id, String type, String name, double value, String logic){
this. id = id;
this. type = type;
this. name = name;
this. value = value;
this. logicpublic String toString()
 {
String temp;
temp = ""ID = "" + id + "", Type = "" + type + "", Name = "" + name +"", value = "" + value +
 "", SpeculateValue = "" + speculateValue + "", Logic = "" + logic + "", Project_Path = "" + project_ path /**
* Returns the id.
* @return int
*/
 public String getId()
 {
return id;
 } /**
* Returns the logic.
* @return String
*/
 public String getLogic()
 {
return logic;
 } /**
* Returns the name.
* @return String
*/
 public String getName()
 {
return name;
 } /**
* Returns the value.
* @return double
*/
 public double getValue() {
return value;
 } /**
* Sets the id.
* @param id The id to set
*/
 public void setId(String id) {
this. id = id;
 } /**
* Sets the logic.
* @param logic The logic to set
*/
 public void setLogic(String logic) {
this. logic = logic;
 } /**
* Sets the name.
* @param name The name to set
*/
 public void setName(String name) {
this. name = name;
 } /**
* Sets the value.
* @param value The value to set
*/
 public void setValue( double value) {
this. value = value;
 } /**
* Returns the speculateValue.
* @return double
*/
 public double getSpeculateValue() {
return speculateValue;
 } /**
* Sets the speculateValue.
* @param speculateValue The speculateValue to set
*/
 public void setSpeculateValue( double speculateValue) {
this. speculateValue = speculateValue;
 } /**
* Returns the type.
* @return String
*/
 public String getType() {
return type;
 } /**
* Sets the type.
* @param type The type to set
*/
 public void setType(String type) {
this. type = type;
 } /**
* Returns the project_ path.
* @return String
*/
 public String getProject_ path() {
return project_ path;
 } /**
* Sets the project_ path.
* @param project_ path The project_ path to set
*/
 public void setProject_ path(String project_ path) {
this. project_ path = project_ path;
 }",requirement:,The subscribermanager shall re execute the model using the speculative values.
Transform code to requirement:,code:,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes",requirement:,Event types shall include decomposing one requirement into two or more requirements.
Transform code to requirement:,code:,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes",requirement:,Event types shall include merging requirements.
Transform code to requirement:,code:,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind",requirement:,Event types shall include decomposing one requirement into two or more requirements.
Transform code to requirement:,code:,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind",requirement:,Event types shall include merging requirements.
Transform code to requirement:,code:,"Merge Model public MergeModel(EBT em)
 {
super( em);
 MinimumNoRects = 3;
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(90,220,1);
 AddEventRect(20,20,1);
AddEventRect(20,70,1);
AddEvent public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int MergeCount = -1;
thisEvent. append(""Merge|"");

for ( int i = 0; i < EventSha",requirement:,Event types shall include merging requirements.
Transform code to requirement:,code:,"Modify Model public ModifyModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(60,80,1);
CurrentEvent = 4;
} public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""Modify|0|"");
thisEvent. append( new Date(). toString()+ ""|"");
 ebs = (EBShape)EventShapes protected void paintComponent(Graphics g)
{
g. drawString(""TESTING MODIFY"",5,5);
super. paintComponent( g);
 }",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"New Modelpublic NewModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
ClearVectors();
AddEventRect(60,80,1);
AddArrow(35,97,59,97);
CurrentEvent = 0;
} public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""New|0|"");
thisEvent. append( new Date(). toString()+ ""|"");
ebs = (EBShape)EventShapes. elem",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"Obsolete Modelpublic ObsoleteModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(60,80,1);
AddLine(60,60,225,135);
AddLine(60,135,225,60);
CurrentEve public StringBuffer GenerateEvent()
 {
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""Obsolete|0|"");
thisEvent. append( new Date(). toString()+""|"");
ebs = (EBShape)EventShapes. e",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"Refine Modelpublic RefineModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(60,80,1);
CurrentEvent = 3;
} public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""Refine|0|"");
thisEvent. append( new Date(). toString()+""|"");
ebs = (EBShape)EventShapes. el",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 ",requirement:,Event types shall include adding new requirements.
Transform code to requirement:,code:,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 ",requirement:,Event types shall include decomposing one requirement into two or more requirements.
Transform code to requirement:,code:,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 ",requirement:,Event types shall include refining one requirement by adding an additional requirement to the existing one.
Transform code to requirement:,code:,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 ",requirement:,Event types shall include modifying a requirement.
Transform code to requirement:,code:,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 ",requirement:,Event types shall include deleting a requirement.
Transform code to requirement:,code:,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 ",requirement:,Event types shall include merging requirements.
